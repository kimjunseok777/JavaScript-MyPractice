
// 스코프 체인

let c = 7;
{
    let c = 3;
    let b = 5;
    console.log(c, b) // 3 5
    {
        let c = 3;
        let d = 2;
        b = 3;  //-> 여기서 b는 블럭 내에서 새로 선언해준 적이 없기 때문에 블럭 밖에 선언했던 b 변수와 같다 -> b가 5에서 3으로 바뀜
        console.log(c, b, d) // 3 3 2
    }
    console.log(b) // 3
    //--> b가 5에서 3으로 바뀌었기 때문 (코드 블럭 안에서 새로 let 을 써서 선언해준 것이 아니라 그냥 b = 3 이라고 재할당 해줘서 b의 값이 바뀐다)
}

//

let A = 7;
function f() {
    let B = 5;
    console.log(A, B) // 7 5
    A = 4;
    
    function fb() {
        let C =5;
        let A =3; //-> fb 블럭 내에서 새로운 A를 선언 -> 즉, 이 블럭 밖에 있는 A와 엄연히 다른 변수이다
        console.log(A, B, C) // 3 5 5
        A = 5; //-> 다시말하지만, fb 블럭 내에 선언해줬던 A 의 변수이다
    }
    fb() // fb가 실행됐다는 소리 -> 하지만 밑에 A에는 영향 x -> fb함수 코드블럭 내에서 A를 새로 선언해줬기 때문

    console.log(A) // 4 --> 7에서 4로 바뀐 것 (만약 위에 A = 4 도 없으면 A = 7 이 된다)
                            //--> 이 콘솔로그에서 5가 나오려면, fb 지역변수 내에서 새로 선언해준 A 가 없어야된다
                            // (그러면 7 -> 4 -> 5 순으로 바뀐 것) => 문제여서 이렇지, 웬만하면 이름 다르게 해주는 게 좋다
}

//-----------------------------------------------------------------------------------------------

// day03 배운 것들 정리 :

// while ~하는 동안에, 코드를 해석할 수 있는 정도
// 함수 --> 특정한 기능을 만든다, 입력과 출력, 설계할 때는 반드시 자연어로 정의
// 함수의 종류 --> 화살표함수(표기), 기명과익명(재사용), 즉시실행함수(선언,실행 동시)
// 콜백함수(다른 함수의 인자로 함수가 전달, 해당 함수를 다른 함수가 실행)
// 재귀함수(함수 안에서 같은 함수 실행 --> 반복)

// 스코프 (지역스코프, 전역스코프)
// 지역스코프 (블럭 안에서만 유효, 삭제)
// 전역스코프 (전체 사용가능, 삭제x) (끝날 때 까지 유지 됨)

// 가비지 컬렉션 : 더 이상 사용하지 않는 메모리를 자동으로 정리하는 것

// 스코프체인 ( 전역변수보다 지역변수가 우선순위가 높다 --> 다른 변수명을 쓰는게 사실 제일 좋다)