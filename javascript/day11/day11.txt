

1. 비동기, setTimeout, setInterval, Promise, 이벤트 루프

2. ajax, axios, fetch, 실행 컨텍스트, 클로저, 프로토 타입 (day12 배울 것들)

-----------------------------------------------------------------------

비동기 :
    자바스크립트는 "싱글 스레드" 이다  -->  컴퓨터 내에서 일을 처리할 수 있는 일꾼이 "1명" 이다
    ( 한번에 한가지 일밖에 처리하지 못하기 때문에, 그래서 자바스크립트가 위에서 아래로 실행되는 것이다 )

    만약에 자바크립트가 실행되는 도중 10초가 걸리는 코드를 만난다면 어떻게 할까?
        1. 기다린다
        2. 컴퓨터 끈다

    "10초가 걸린 후에 실행되는 코드" 와 "시간이 소요되는 코드" 를 다른 일꾼에게 맡길 수 있다면? (외주 맡긴다고들 한다)
    ( 10초가 걸리는 코드를 포장해서 다른 곳에 맡겨버리는 것 )  -->  10초를 기다릴 필요 없이 나머지 자바스크립트를 실행한다

    동기(순차적)  -->  위에서 아래로 순서대로 실행한다
    비동기(순차적 X)  -->  순서대로 실행하지 않는다

    ex)
    코드 및 함수 실행 예시 :
    a(0.00001초) -> b(10초) -> c(b) -> d(0.00001초)
    동기적으로 실행된다면 10.00002초 뒤에 사용자는 화면을 본다

                                    b(10초) -> c(b)
    a(0.00001초) -> d(0.00001초)

    화면을 그려주는 코드는 d까지만 있어도 충분하기 때문에
    화면을 0.00002초에 그려줍니다
    그리고 b랑 c가 끝나면 추가적인 부분의 화면만 다시 더 그려준다 (b와 c는 비동기로 묶어서 따로 빼서 실행시켜주는 것)

    ex) 화면이 전체 다 그려질 때까지 쌩판 안보여주는 것이 아니라, 로딩창 같은 거 먼저 보여줘서 UX 를 더 좋게 해줄 수 있다
            -->  이것을 우리는 "비동기 처리" 라고 한다  -->  오래 걸릴 것 같은 친구들은 따로 빼서 실행시켜주는 것 (비동기 함수)
            -->  순차적인 것이 먼저 실행된 후 비동기가 실행된다

-----------------------------------------------------------------------

비동기 함수 :
setTimeout(몇초 후에) , setInterval(몇초 마다)

    setTimeout
        "특정 시간 이후" 에 원하는 코드블럭을 실행하는 비동기 함수
        ex) 5초 뒤에 화면이 이동합니다 (예약을 거는 것 --> 문자 메세지 예약 전송 같은 것)  -->  화면 이동은 location 이나 history 등 사용하면 된다
        clearTimeout -- 동작 취소

    setInterval
        "특정 주기 마다" 원하는 코드블럭을 실행하는 비동기 함수
        ex) 자동으로 넘어가는 슬라이드 배너 (5초마다 자동 실행), 타이머 같은 것
        clearInterval -- 동작 취소

-----------------------------------------------------------------------

비동기 함수는 동기 함수가 모두 실행되어야만 실행됩니다  -->  실행은 같이 하지만, 동기적 코드가 모두 끝나야, 비동기 코드들이 결과를 반환한다
(순차적인 것이 먼저 실행된 후 비동기가 실행된다)

ex)
    console.log("a")
    
    setTimeout(() => {
        console.log("b")
    }, 0)  //--> 0초 후에 실행이지만, b는 비동기 함수이기에 마지막에 실행된다
    
    console.log("c")

    결과값 실행 순서 : a -> c -> b

-----------------------------------------------------------------------

이벤트 루프 :
    브라우저의 데이터의 실행 환경을 제어하는 관리자
    -> 실행할 때 콜스택 , WebAPIs , 콜백큐가 빙글빙글 도는 형태로 실행되는 것을 확인할 수 있다
    ( 시간이 걸릴 것 같은 친구들은 따로 뺀 다음에, 시간이 안 걸리는 친구들을 먼저 실행하고 실행하는 것 )

    이벤트 루프에 대한 구성 :
        ) 1. 콜스택 : 동기적 코드 저장, 실행

            -> 자바스크립트에서 원시값과 변수의 값은 콜스택에 저장된다. ( 동기적으로 실행하는 변수, 함수 등을 저장하는 공간 )
            -> 여기서 "비동기" 들은 WebAPIs 로 이동한다


        ) 2. WebAPIs : 비동기적 코드를 실행, 결과를 콜백큐로 전달

            -> 콜스택에서 비동기라는 친구들을 만나면, 이 비동기라는 친구들이 WebAPIs 로 이동한다
            -> WebAPIs 에는 어떤 것들이 이동이 되냐면 -> 백엔드에 대한 데이터 요청, 비동기 함수, DOM의 addEventListener 같은 친구들이 이동
            -> 그래서 WebAPIs가 이 친구들을 실행을 시켜주는데, 하지만 그 결과가 바로 사용자들에게 적용이 되지는 않고 callback queue 로 이동이 된다


        ) 3. callback queue ( task queue, microtask queue ) : 비동기적 코드의 결과를 저장했다가 결과를 반환

            WebAPIs 가 실행되고 나면 실행 결과는 콜백큐로 이동된다
            *** 콜백큐는 콜스택이 모두 비워져있는 것 (모두 실행된 상태) 을 확인하면 결과를 순차적으로 실행 ( 보관소라고 생각하면 된다 ) ***

            -> 콜백큐는 "task queue" 와 "microtask queue" 같은 것들이 있다
            -> task queue : 백엔드에 대한 데이터 요청, setTimeout 이런 친구들이 들어간다
            -> microtask queue : task queue 얘네들을 처리하고 나서의 요소들이 들어간다 (then, catch 같은 친구들)
                -> task queue 가 먼저 실행이 되고, 그 다음에 microtask queue 가 순차적으로 실행이 된다

        
        스택과 큐 ( 일종의 자료구조 방식 : 데이터를 뭉쳐놓은 형태 )

            스택 (항아리)
            Last in First Out (LIFO) (후입선출)
            -> 마지막에 들어온 순서대로 실행하는 것 (항아리 안에 물건을 쌓아놨을 때를 생각하면 됨 -> 맨 처음에 넣었던 물건을 뺄 수가 없음)
            -> 처음 들어온 것이 마지막에 실행
            
            큐 (빨대)
            First In First Out (FIFO) (선입선출)
            -> 처음에 들어온 순서대로 실행하는 것 (항아리 밑에 구멍이 뚫렸다고 생각하면 됨 -> 그럼 처음에 넣었던 물건을 뺄 수가 있음)
            -> 처음 들어온 것이 먼저 실행

            ** 이벤트 루프에서 가장 중요한 말 --> 순차적 (동기적) 인 것이 먼저 실행된 후 비동기가 실행된다 **

            ) 내용 정리 : 동기적인 코드들은 "콜스택" 에 저장되었다가 실행한다, 하지만 비동기적 코드들은 콜스택으로 가지 않고 "WebAPIs" 로 이동되고,
                                여기서 실행을 한다 그리고 실행된 후 결과는 "콜백큐" 로 이동하고, 콜백큐에서는 콜스택에 있는 동기적 코드들이 모두 실행이 되면
                                (콜스택이 비어있는 것을 확인하면) 비동기적 코드들의 결과를 반환한다

-----------------------------------------------------------------------

비동기 처리 :
    비동기를 후에 "처리하는 것" 을 알아보자
    ex) 비동기 요청이 끝이 났다 -> 비동기 이후에 실행해야하는 요직이 필요하다  -->  이것을 "비동기 처리" 라고 한다

    b(10초) -- 비동기
    c(b) -- 동기 (c는 동기지만, 실행하기 위해서는 비동기인 b가 필요하다)

    비동기 이후에 실행해야하는 동기 코드까지 하나의 블럭으로 묶을 필요가 있다 (비동기 처리)
    c는 동기지만, b와 묶어서 비동기로 만들어버리는 것

    --> 비동기로 만드는 것의 대표적인 친구는 Promise 와 async await 가 있다 (Promise 사용하면 then 으로 비동기 처리 해줘야한다)

    1. Promise
        비동기 이후의 대기, 실행, 실패 유무에 따라 분기처리를 할 수 있도록 도와주는 함수

        사용법 :
        new Promise( (resolve, reject) => {
            console.log("안녕하세요")

            resolve(-- 매개변수 --)  //  실행 완료
            reject(-- 매개변수 --)  //  실행 실패 (에러가난 것)

            --> 예시 : 회원가입하는데 이메일이 중복될 때 -> 모달로 실패했다는 거 보여주고 싶을 때
            --> Promise 라고 하는 것은 내가 실행하려 하는 것이 성공 , 실패에 따라서 분기처리 해줄 수 있음

        }).then(( resolve의 매개변수 -> 예시 : user 백엔드 요청 코드 ) => {
            code...
            alert(`환영합니다, ${user.name}님`)
            window.location.href = "주소"

        }).catch(( reject의 매개변수 ) => {
            if(response.status === 404) {
                alert("잘못된 접근입니다")  //--> 이런 식으로 에러났다고 콘솔에 찍히는 것이 아니라, 에러를 다르게 처리해주고 싶을 때 사용 => "에러 핸들링"
            }
        })

        ** then : 이 비동기요직 (시간이 걸릴 수 있는 요직) 이 실행되고 나서 어떻게 할 것인지 정할 수 있는 것

        ** catch : 에러가 났을 때 콘솔에 찍히기 전에, 그 에러를 잡는 것
            --> 에러를 중간에 가로채기 때문에 올라가지 않는다 --> 원래라면 콘솔에 띄워주는 최상위 에러처리로 넘어가야 함
            --> 중간에 에러를 잡았으니까 에러 처리를 해줄 수 있음  (에러 핸들링)

        ** Promise 는 비동기이기 때문에 WebAPIs 로 이동 후에, 콜백큐의 "task queue" 로 이동을 한다
            (굳이 순서를 매기자면 setTimeout이 더 빨리 실행되기는 한다)
            
                --> 그리고 then , catch 의 영역이 "microtask queue" 로 이동을 한다

-----------------------------------------------------------------------

2. async await