
빌트인 객체 : 자바스크립트가 만들어질 때부터 "내장되어있는 객체" 를 말한다
대표적예시 ) console.log
                    코드로 풀이해보면 :
                    const console = {
                        log(){
                            ...
                        }
                    } --> 이런식으로 객체에는 함수가 들어갈 수 있다

                    ==> 즉, 우리가 디버깅할 때 쓰는 "콘솔로그" 는 "닷 접근법" 으로 console 이라는 객체 안에 log 함수를 실행시켜준 것이다


---------------------------------


Math :
    max, mini, random, floor, trunc, ceil, round, abs, sqrt, cbrt

    Math.max(1, 2)  //  2 --> 괄호 안에 들어있는 값 중에서, 가장 높은 값 (최댓값) 을 알려준다
    Math.min(1, 2, 3, 4, 5)  //  1 --> 괄호 안에 들어있는 값 중에서, 가장 낮은 값 (최솟값) 을 알려준다
    Math.random()  //  0~0.999... 사이의 무작위 소수가 나온다
    ex)
        Math.random()  //  0~0.999.... 사이의 무작위 소수가 나온다
        Math.random() * 10  //  0~9.999.... 사이의 무작위 소수가 나온다
                                            // 여기서 숫자 1을 더하면 1~10.999....
                                            // 여기서 소수점 아래로 버리면 1~10 이 랜덤으로 나온다
        Math.random : 특정 자연수나, 랜덤한 자연수를 구할 때 사용
        Math.floor(Math.random() * 10 + 1)  //  1~10 랜덤한 수

        Math.floor  (소수점 버림)  -->  (양수일 때 소수점 이하를 삭제) "음수"일 때는 문제가 생길 수 있음 (음수가 들어올 가능성이 있다면 trunc 사용)
        Math.trunc  (절삭)  //--> -1.5 에서 버리면 -1 이 된다 (음수일 때 소수점 이하를 삭제)
        Math.ceil  (올림)
        Math.round  (반올림)  //--> 1.2 면 1이 된다  /  1.8이면 2가 된다
        Math.abs(-5)  //  5  -->  절대값 : 음수로 된 수를 양수로 바꿔주는 역할

        Math.sqrt(a)  //  제곱근  -->  9의 제곱근은 3  /  16의 제곱근은 4
                                    //  제곱근 : 어떤 수 a를 두 번 곱하여 x가 되었을 때에, a를 x에 대하여 이르는 말

        Math.cbrt(a)  //  세제곱근  -->  8의 세제곱근은 2  /  27의 세제곱근은 3
                                    //  세제곱근 : 어떤 수 a를 세 번 곱하여 x가 되었을 때에, a를 x에 대하여 이르는 말
        
        quiz)
            빨주노초파남보 7가지의 색상 중 버튼을 클릭하면 랜덤으로 색상이 변경하는 기능
            const colors = ["빨", "주", "노", "초", "파", "남", "보"]

            function randomColor() {
                let randomIndex = Math.floor(Math.random * 7)  //  0~6 사이의 자연수가 나온다
                $div.style.backgroundColor = colors[randomIndex]
            }
            ==> 이렇게 여러가지의 값중에서 "랜덤"하게 접근해야 할 때는 "Math.random" 을 사용하면 된다

---------------------------------


Number
    Number.toString()  //  "숫자"를 "문자열"로 반환한다  ==>  이거 잘 안된다, 잘 모르겠음 @@@

    Number("5")  //  "문자열"을 "숫자"로 반환  -->  이렇게 넘버 객체 자체에다가 스트링으로 숫자를 넣을 수도 있음
    parseInt("5")  //  "문자열"을 "숫자"로 반환  -->  넘버 객체에 있지는 않지만, 넘버와 비슷한 역할을 한다 (Int 는 정수를 나타냄)

    ==> Number, parseInt, toString 모두 "형변환" 시켜주는 것이다


---------------------------------


String : "유사배열객체"  -->  "문자열"  -->  "문자"로 만들어진 "배열"
    "안녕하세요".length  //  5
    "안녕하세요".charAt(3)  //  "세"  (index 로 구분 --> 0부터 시작함 --> 배열의 index와 같다)
                                            // charAt(인덱스) : 문자열에서 지정된 인덱스의 특정 문자를 가져온다
                                            // "안녕하세요"[3]  -->  이거 해도 "세" 나온다

    "안녕하세요".concat("저는 김준석입니다")  //  안녕하세요 저는 김준석입니다
    " ".split()  //  특정 기준 문자열을 분할하여 배열로 반환  (문자열 -> 배열)
    "안녕".repeat(3)  //  안녕안녕안녕

    ==> 즉, 문자열 같은 "유사배열객체" 는 배열처럼 내장함수 등을 사용하여 배열처럼 활용할 수도 있다


---------------------------------


Date
    날짜와 시간을 생성하는 빌트인 객체지만, 잘 사용되지 않습니다
    단점 - "사용자 (로컬 환경) 기준"으로 시간을 다룹니다 (로컬 : 사용자 컴퓨터 기준)
    ==> Date는 잘 쓰이진 않지만, 사용법은 중요하다

    --> "서버의 시간"을 가지고 올 수 있는 dayjs, momentjs, luxon 라이브러리(도구)를 자주 사용한다

    UTC00
    협정세계시 (1972년 1월 1일 지정)
    유닉스의 시간이 지나기 시작한 1970년도 1월 1일 자정 기준 몇초가 지났는지 ms 단위로 반환한 것을 UTC time 이라 한다
    --> 1초는 1000ms (밀리세컨드)
    --> 단위 앞에 m(밀리)가 붙으면 1000분의 1이라는 뜻

    UTC : 협정세계시
    KST : 한국표준시 = UTC + 09:00

    시간은 UTC 타임으로 다루기 때문에, Date는 잘 사용하지 않는다
    => "자바스크립트로 날짜 관련된 데이터를 다룰 수 있다" 정도 알고 있자


---------------------------------

Object
Array

---------------------------------------------------------------------------------------------------


Map, Set
    해시 테이블 구조를 기반으로 하는 자료구조의 한 종류
    해시 : 암호화된 값 -> "키" 와 "값" 을 암호화하여 저장하여 데이터의 "검색" 과 "추가" 에 용이하도록 설계한 것 (Map, Set) -> (해시테이블 구조)

    ex)  3000개의 길이를 갖고 있는 배열에서 특정 값이 존재하는지 검색할 경우  -->
    includes()  -->  3000개의 요소 중, 같은 요소가 있는지 3000개 다 찾아서 비교  -->  느릴 수 밖에 없음

    암호화된 값으로 데이터를 저장하여 해당 암호화 값이 일치하는지만 확인, 그리고 결과를 "반환"
    따라서 복잡한 데이터일수록 수십배 빠른 속도로 데이터를 찾아낼 수 있습니다
    ex) ~~만한 길이에 있는 객체들을 보고 찾는 것보다, 암호화 값이 있는 객체를 보는 것이 훨씬 유리하기 때문이다


---------------------------------


Map : 배열 (배열 안에 배열  -->  4차원 배열)
    키가 있는 값을 저장하는 것은 객체와 유사하다
    Map은 문자열만 키로 지정할 수 있는 객체와 달리, 다양한 "자료형(타입)" 을 "키" 값으로 설정할 수 있음 -> 숫자도 "key" 값으로 저장할 수 있음

    ex) --> 항상 자바스크립트의 "키" 값은 "문자열"이다 (따움표 없이 써도 자동으로 문자열로 변환시켜주는 것이다)
        
        Object {
            key(string) : value
        }

        Map  -->  "배열 형태"로 저장이 된다 (배열 안에 배열이 있다 --> "4차원 배열" 이라 한다)
            [[key(any), value], [], [], []]
            key(any) --> 여기서 키는 string 뿐만 아니라 어떠한 자료형타입이든 가능하다 (객체를 넣어도 되고, string이 아닌 다른 친구를 넣어도 된다)

        사용법:
            // 배열 형태로 저장  -->  순회 가능하기 때문에 forEach, for of 사용 가능
            const 변수명 = new Map()  -->  배열 생성 (4차원 배열) 하여 변수에 담아준 것
            변수명.set(key, value)  -->  배열 추가
            변수명.get(key)  -->  특정 배열만 가져오기 (value를)
            변수명.has(key)  -->  있는지, 없는지 검색하는 것인데, includes 보다 훨씬 빠르다  -->  true 또는 false 를 반환
                                                (But "특정한 값" 이나 "index" 에 접근하는 것은 배열이 훨씬 빠름)
            변수명.delete(key)
            변수명.clear()  -->  아예 다 삭제한다
            변수명.size  -->  요소의 개수 반환

            ==> Map 은 자료구조의 데이터가 너무 많을 때, 검색과 추가를 용이하게 하기 위함
            ==> 자료구조의 데이터가 많이 추가될 가능성이 있는 상황에서도 Map 을 쓴다


---------------------------------


Set : 객체 (유사 배열 객체)
    중복을 허용하지 않는 값을 모아놓은 "객체" (유사배열객체)
    "키"가 없는 객체  -->  value === key 이다  -->  value 가 곧 key 이기 때문에 중복된 값이 있을 수 없다
    "Set은 중복된 요소를 제거하기 위해 사용거나, Map처럼 검색하기 위해 많이 쓰인다"

    객체에서 중복된 "키"값은 있을 수가 없다 (value는 중복된 값이 있을 수 있는데, Set에서는 value가 곧 key이기 때문에 중복된 값이 나올 수 없다)
    ex)
        const junseok = {
            age: 20,
            age: 30
        }
        console.log(junseok.age)  //  30  -->  전에 적었던 age: 20이 없어진다(밑에 적었던 "age: 30"에 덮힌다)  -->  이처럼 중복되면 안됨

    사용법:
        const 변수명 = new Set()
        변수명.add(value)  -->  객체 추가
        변수명.has(value)  -->  true 또는 false 를 반환
        변수명.delete(value)  --> 위의 add 나 delete 를 보면 알 수 있듯이, key 가 곧 value이기 때문에 value로 한다 (key 가 없다)
        변수명.clear()
        변수명.size  -->  객체에 들어있는 요소의 개수 반환


---------------------------------


Object  vs  Map, Set

1. 간단한 자료구조라면 Object 를 사용하는 것이 훨 좋다  -->  Object
2. 중복된 요소를 제거해야한다  -->  Set (무조건 Set을 쓰면 된다)
3. 대용량의 데이터 (그럴 가능성이 보여도)  -->  Map
