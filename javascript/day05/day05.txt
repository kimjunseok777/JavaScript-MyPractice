
배열 내장함수 :
    (중요한것 -> 기능 / "복사본"을 만들 건지의 유무 / "반환" 값의 유무)  -->  원본 배열이 필요한지, 복사본이 필요한지 스스로 정의
    ("원본" 배열을 사용하느냐, "반환" 하는 배열을 만드느냐의 차이 구별 잘하기)

    내장함수 - 원본 : push, unshift, reverse, splice(start, count, item)
    내장함수 - 반환 : pop, shift, concat, join(배열 -> 문자열), split(문자열 -> 배열), slice(start, end -> 복사본 생성)
    내장함수 - 리서치 : indexOf, includes

-----------------------

    push() => "원본"

                ()안에 데이터를 "원본" 배열의 맨 끝 요소로 추가 (배열에 요소를 추가할 때 사용)
                ex) arr = ["짱구", "흰둥이"]
                       arr.push("신형만")  //--> "쿠로미퀴즈" 에서 여기서 콘솔 찍으면 왜 "갯수(길이)"가 나오는가?
                       console.log(arr) // 짱구 흰둥이 신형만  //--> "신형만"이 마지막 요소로 추가된 것 

-----------------------

    pop() => "반환"

            원본 배열의 "맨 끝 요소"를 제거 후, 제거된 요소를 "반환"
            ex) let el = arr.pop()  //--> 제거된 요소를 반환하기에 새로운 변수에 담아준 것, 원본 배열도 제거된 상태로 바뀐다
                   console.log(arr) // 짱구 흰둥이
                   console.log(el) // 신형만  -->  제거된 요소를 "반환"한다

-----------------------

    unshift() => "원본"

                ()안에 데이터를 "원본" 배열의 맨 앞에 추가 (push가 맨 뒤 요소 추가라면, unshift는 맨 앞 요소 추가이다)
                ex) const arr = [1, 2, 3, 4]
                       arr.unshift(0)
                       console.log(arr) // 0 1 2 3 4

-----------------------

    shift() => "반환"

            원본 배열의 "맨 앞 요소"를 제거, 제거된 요소를 "반환" (pop이 맨 뒤 요소 제거 후 반환 / shift가 맨 앞 요소 제거 후 반환)
            사용법은 pop과 같다

-----------------------

    concat() => "반환"

              -->  배열을 합친 후 "반환"
            arr1.concat(arr2)  ==>  arr1 에 arr2 배열을 합치겠다는 소리
                            ()안에 두 배열을 합친 하나의 "복사본 배열"을 "반환"
                            ex) const arr1 = [1, 2, 3, 4]
                                   const arr2 = [5, 6, 7, 8]

                                   arr1.concat(arr2) // 1 2 3 4  -->  (합쳐지긴 한건데, 반환하는 식이기에 새로운 배열을 만들어줘야함)
                                   console.log(arr1)

                                   let concat = arr1.concat(arr2) // 새로운 배열(변수)을 만들어 준 것
                                   console,log(concat) // 1 2 3 4 5 6 7 8
                                   * 새로운 배열이 필요한지, 원본 배열을 수정해야하는지 판단 ("반환"하기 때문에 새로운 배열이 필요한 것이다)

-----------------------

    join() => "반환" (배열 -> 문자열)

            배열 사이 ()안에 기재한 문자가 삽입된 "문자열을 반환" (배열 => 문자열)
            ex) const ph = ["010", "1234", "1234"]
                    const strph = ph.join("-")  // --> 배열들 사이사이에 하이픈을 넣어서 문자열로 만들어 주겠다
                    console.log(strph) // "010-1234-1234"
                    *join은 "배열"을 "문자열"로 만들고 싶을 때 사용 (괄호 안에 아무것도 안적어도 됨) ex) (" ")

-----------------------

    reverse() => "원본"

                "원본" 배열의 역순 배치
                ex) const arr = [1, 2, 3, 4]
                arr.reverse()
                console.log(arr) // 4 3 2 1

-----------------------

    split() => "반환" (문자열 -> 배열)

            ==>  새로운 변수를 만들어줘야한다 (반환한다)
            "문자열"을 ()안의 문자 기준으로 배열로 생성 (문자열 => 배열) (기준되는 요소를 적어주면, 사라지면서 문자열이 됨)
            ex) const str = "안녕하세요"
            str.split() ["안", "녕", "하", "세", "요"]
            "010-1234-1234".split("-") // ["010", "1234", "1234"]  //--> 기준되는 요소가 사라진다

-----------------------

    splice(start, count, item) => "원본"

         => "원본" 배열에 특정 부분을 "제거 or 대체" 하고 싶을 때 사용
            - "원본" 배열의 요소를 제거한다
            - 제거한 부분에 item으로 대체할 수 있다 (적어도 되고 안 적어도 됨)
            - start(index), count(개수)  -->  "나는 이 index 부터 시작해서, 몇개 지울거야" 라는 의미
                여기서 개수(count)는 index를 포함하여 시작

            ex) const arr = [1, 2, 3, 4, 5, 6, 7]
            arr.splice(3, 3, "hello")  -->  4 부터 6 까지 지우고, hello를 넣어줌 (item에서 더 추가하고 싶으면, 콤마로 이어서 작성)
            // 1, 2, 3, hello, 7

-----------------------

    slice(start, end) => "반환" (잘라낸 부분 복사본 생성)

            => 원래 있는 배열에 특정 부분을 잘라서 그 부분을 사용하고 싶을 때 사용 (제거하는 것이 아니다)
            - "원본" 배열의 특정 구간을 잘라서 "복사본 생성"
            - splice와 달리 제거하지 않습니다 (원본 배열 영향 안미침 --> 그냥 복사본을 생성)
            - start부터 시작해서 end "직전" 의 index 범위의 복사본 생성 (end를 포함하지 않는다)
            
            ex) const arr = [1, 2, 3, 4, 5, 6, 7]
            let a = arr.slice(3, 6)
            console.log(a) // --> 4, 5, 6

            ==> slice에서 start와 end값에 음수(-)가 붙으면 뒤에서부터(역순) 시작이다 ( -1부터 시작하고, end를 미포함하는 것은 같다 )

-----------------------

    indexOf => "리서치"

            - 배열에 특정한 값의 인덱스를 찾기 위해 사용
            - 이 배열에 해당 값이 포함되어있는지 확인하기 위해 쓰였으나, 현재 그런 것은 "includes"를 많이 사용
            - indexOf는 내가 찾고자 하는 요소에 "index 번호" 가 필요할 때 사용한다 (즉, 정확한 index 위치를 알아야할 때)

            ex) const a = [1, 2, 3, 4, 5, 6, 7 ....... 1000000]
            a.indexOf(500000)  // --> 이렇게 내가 50만이라는 것의 인덱스가 필요할 때 이렇게 특정 값의 이름을 찍음
            a[499999]  // --> 그러면 이렇게 이름 찍은 것의 "인덱스" 를 알려준다  (인덱스는 0부터 시작하기에 499999 이다)

            ==> ***  배열에 해당 값이 존재하지 않을 때는 "-1" 이 뜬다  ***

-----------------------

    includes => "리서치"

            - a.includes(1) // true / false  --> 배열 안에 괄호에 적었던 것이 포함돼있으면 ture / 아니면 false 가 나온다


-----------------------------------------------------------------------------------------------------------


배열 고차함수 :
    - 매개변수(인자)로 "콜백함수"가 들어가는 경우가 많습니다
        ("함수"의 매개변수로 "함수"가 들어가고, 그것을 실행시켜주는 것을 "콜백함수" 라고 한다)
    - 배열을 "순회"하는 경우가 많습니다
    - 배열의 유틸 기능

    고차함수 - 반환 : map, filter, find(요소/객체 반환), findIndex(배열 반환)

-----------------------

    map
        .map(() => {})
        배열을 순회 (순서대로 반복) (반환)
        반복 시 마다 각 요소에 "콜백함수의 반환 값"을 요소로 하는 "새로운 배열을 생성"

        ex)
        const posts = [
            {
                id: 1,
                title: "안녕하세요-1"
            },
            {
                id: 2,
                title: "안녕하세요-2"
            }
        ]

        // 위에 것을 아래있는 배열 출력값으로 만들려면 어떻게 해야 하는가

        ["<div>안녕하세요-1</div>", "<div>안녕하세요-2</div>"]  //--> 출력값은 이렇게 "새로운배열" 을 생성한 것

        posts.map(()=>{})
        posts.map((name, "index -> 이렇게 필요하다면 인덱스도 같이 적어도 됨(필요없음 쓰지마셈)")=> {return name.title})
        posts.map((name)=> name.title) // ["안녕하세요-1", "안녕하세요-2"]
        ==> "반환" 하는 값을 요소로하는 배열이 나온다
        ==> 기존에 있는 배열을 개조해서, 새로운 배열을 만든다
        ==> 조건문도 들어갈 수 있다  -->  ex) 나는 짝수번째 index는 return하지 않을 거야  //  ["안녕하세요-1"]

-----------------------

    filter
        .filter(() => {})
        - 특정한 배열에서 내가 "원하는 요소"들만 찾아서 새로운 배열을 "반환"
        - 특정한 조건에 맞는 배열 필요할 때 사용, 특정한 값을 삭제한 배열
        - 특정한 조건에 맞는 배열 모두 반환한다

        const userList = [
            {
                name: "김준석",
                age: 20,
                height: 190
            },
            {
                name: "김사과",
                age: 23,
                height: 170
            },
            {
                name: "이멜론",
                age: 17,
                height: 153
            }
        ]
        const filterUserList = userList.filter((el) => el.age > 20)
        console.log(filterUserList)  //  [{김준석...}, {김사과...}]

        // filter로 삭제하는 거
        const deletedUserList = userList.filter((el) => el.name !== "김준석")  //-> el이 "김준석"이 아닌 것들만 가져오겠다라는 뜻 ("김준석" 인 것 삭제된 배열 반환)
        // splice 는 원본 배열의 값을 삭제하지만,  -->  splice(start, count, item)
        // filter 는 원본 배열의 값을 삭제하지 않고 새로운 "복사본"을 생성한다 (반환하는 함수)  -->  slice와 비슷하지만, 기능이 약간 다르다

-----------------------

    find
        .find(() => {})
        - 특정한 배열에서 특정한 조건을 만족하는 "요소"를 찾아서 "반환" ("배열" 을 반환하는 것이 아니다 -> "객체" 를 반환한다)
        - 배열을 순회한다, 조건식에 맞는 가장 "첫번째" 요소 (조건에 맞는 것을 찾았다면, 더이상 순회, 검색하지 않는다)  -->  조건에 맞는 가장 첫번째 발견된 요소 반환

        ==> 맨 뒤에서부터 찾고 싶다면 reverse를 이용하면 된다

-----------------------

    findIndex
        .findIndex(() => {})
        - find 와 모든 원리가 같지만 "index" 를 반환합니다
        - 값이 없다면 "-1" 을 반환  -->  내장함수의 indexOf 도 값이 없다면 "-1" 을 반환한다


--------------------------------------------------------------------------------


    reduce
    every
    some
    sort