
1. 배열의 내장함수

    내장함수 - 원본 : push, unshift, reverse, splice(start, count, item -> 제거 or 대체)
    내장함수 - 반환 : pop, shift, concat, join(배열 -> 문자열), split(문자열 -> 배열), slice(start, end -> 복사본 생성)
    내장함수 - 리서치 : indexOf, includes


push
unshift
---> 배열에 요소를 추가하고 싶다

pop
shift
---> 배열에 요소를 제거하고 싶다

splice (특정 구간 제거 or 대체) (start, count, item)
---> 배열에 특정 요소 구간을 제거하거나 대체하고 싶다

concat
---> 두 개의 배열을 합성

slice (슬라이스 - "복사본" 생성) (start, end)
---> 배열의 특정 구간만 필요할 때 [1~10]  ->  [4~6] 만 가져와서 쓰고 싶어

join
---> "배열" 을 "문자열"화 시킬 필요가 있는지 (문자열로 합치기)

split
---> "문자열" 을 "배열"화 시킬 필요가 있는지 (배열로 쪼개기)

reverse
---> 배열의 역순이 필요할 때

indexOf (index 값을 알려준다)
---> 배열의 특정 값(문자, 숫자같은 실제 값)이 있는 요소에 "인덱스"에 접근해야할 때
        (객체타입이나, 배열이 들어갈 때는 참조값(주소)이 들어간다 -> 그래서 그런 것들은 indexOf로 찾을 수 없다 -> 특정 값만 찾을 수 있음)

includes (true / false -> 값의 존재 유무를 알려준다)
---> 분기처리 -> 있다면~ or 없다면~ 이런식으로 사용
        (indexOf 와 마찬가지로 특정한 값이 들어가야한다)

** 배열 안에 "객체" 를 찾을 때는 indexOf, includes 가 아닌 find, findIndex 를 사용해야 한다 --> 객체는 원시타입이다. 즉, 힙메모리에서 주소값을 찾는 것이기 때문

---------------------------------------------------------------------------------------

2. 배열의 고차함수

map
---> 순회해야 하는가?  새로운 배열을 반환한다 (변형시킬 수 있음 -> 어떤 요소를 추가하거나, 특정 요소만 가져오거나 등등)
        (순회 -> 변형(변형 안 시킬 수도 있음) -> 새로운 배열 생성)

filter  (조건에 맞는 배열 모두 반환)
---> 특정한 "조건"에 맞는 새로운 배열을 반환한다
         특정한 요소들을 제거할 때도 사용할 수 있다  -->  ex) 나는 나이가 20살 이하인 친구들은 이 배열에서 뺄 거야 --> 반환
                                                                                       ex) arr.filter((el) => {return el.title !== 1})  -->  이런 식으로 부정연산자 써서 제거하는 용도로도 사용

find  (조건에 맞는 배열 첫번째 찾으면 그것만 "객체" 로 반환)
---> 찾고자(비교하고자)하는 값이 "객체" 타입일 때 사용
         특정 조건에 맞는 요소 하나 (특정 조건에 맞는 객체 첫번째 찾으면, 순회 종료)

findIndex  (조건에 맞는 배열 첫번째 찾으면 그것만 "인덱스 값" 으로 반환)
---> find와 같으나, "index" 를 반환 (특정 조건에 맞는 객체 첫번째 찾으면, 순회 종료)

---------------------------------------------------------------------------------------

JSON 과제  -->  JSON : 자바스크립트 객체 표현식 (JavaScript Object Notation)

    ex)
    const post = {
        id
        title
        content
        Comments: [ ]
        User: [ ]
    }

    1. 문제를 낼거에요 (5개 이상 ~ 10개 까지)
    2. 문제의 정답을 자기 자신은 알고 있어야함
    3. 메일로 제출 --> 문제를 익명으로 전체 공개
        (korpg95274@gmail.com)

    ** 똑같은 화면인데, 페이지마다 다르다면 -> 백엔드에서 받아온 데이터이다

---------------------------------------------------------------------------------------

*****  day06  *****

배열의 고차함수 나머지 4개 : reduce, every, some, sort

    reduce
        순회, * 누적값 * 구할 때 많이 쓰임
        현재 요소와 다음 요소, 그리고 그 요소에 연산된 누적 값을 반환 // reduce 는 빠르지만, 가독성이 안 좋음

        ex) const numArr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        numArr.reduce((sun(누적값), n(현재요소)) => {
            return sum + n
        }, 0)  //--> 이렇게 기본 값 0으로 설정한 것 / 기본값이 없으면 "첫번째 인덱스"가 기본값
                    -->  기본값이 1000이면 누적값(sum)이 1000으로 시작한다  -->  즉, 1000 + 1 + 2 + 3... 이렇게 된다
        //--> 그럼, 기본값 설정하면 (기본값 다음이 첫번째 인덱스)

        reduce의 첫번째 순회시 누적값의 초기값은 배열의 첫번째 요소
        현재 요소는 두번째 요소
        단, reduce의 두번째 인자에 누적값의 기본값을 설정할 수 있음
        만약 누적값의 기본값이 있다면 sum은 기본값이 되고 n은 첫번째 요소가 된다

        --> 즉, 누적값(sum) 은 축적되는 값이고, 현재요소(n) 는 순회하면서, 바뀌면서 계속 더해진다
        --> 누적값의 초기값을 정해주냐, 정해주지 않고 0으로 시작하느냐 그 차이이다

        ==> 배열의 모든 요소를 순회하면서 "누적되는 값" 이 있다면 reduce를 고민
                다음 연산에 이전까지의 연산이 필요할 때 reduce 사용

        for문으로 ex)
            let sun = 0;
            for () {
                sun = sum + numArr[i]
            }

        ex)  //--> 이거 잘 이해 안됨
        const ph = ["010", "1234", "1234"].reduce(str, number, index) => {
            if(index === 1) return str += "-****"
            return str += "-" + number
        }
        ==> 이렇게 문자열을 연결할 때도 reduce를 사용할 수 있다
        ==> reduce를 이해하기 위해서는 많은 시간 소요를 해야함 (지금 당장은 기피해도 된다) -> 일반 for문으로도 할 수 있음

-----------------------

    every
        배열에서 "모든 요소"의 조건이 참인지 확인하는 것 (하나라도 false면 false이다)
        ex) const arr = [2, 4, 6, 8]
        arr.every((el) => el%2 === 0)  //--> 이 모든 값이 true인지를 true, false 로 구분한다

        => 특정 조건이 모두 만족하느냐에 따라서 분기처리할 때 사용

-----------------------

    some
        배열에서 "하나 이상의 요소"가 참인지 확인하는 것 (하나라도 true면 true이다)
        ex) const arr = [2, 4, 5, 8, 7]
        arr.some((el) => el%2 === 1)  //  true  -->  5, 7이 true이기에 true가 나온다

        => 특정 조건에 하나라도 만족하느냐에 따라서 분기처리할 때 사용

        ex)
        [a, undefined, undefined, undefined, undefined,]
        => 배열에 a라는 값이 하나라도 있다면에 따라서 분기처리  -->  "el == a" 를 하면 true 가 나온다

-----------------------

    sort
        원본 배열에 요소 크기대로 정렬  ==>  "반환"하는 배열도 만들고, "원본 배열"도 바꾼다
        => (** 원본배열도 바꾸기에 **, 사용할 때 주의해야한다)
        ex) const arr = [5, 3, 1, 2, 5]
        arr.sort() // 1, 2, 3, 4, 5  //--> 가, 나, 다, 라... 이런 배열이면 ㄱ, ㄴ, ㄷ, ㄹ ... 순으로 된다 (영어도 마찬가지)

        => .arr((a, b) => a - b)
        => 유니코드상에서 10이 2보다 앞에 있기 때문에, a-b는 숫자를 직접 이전과 이후를 비교해준 것 뿐
        => 반환도 하지만, 원본배열도 바꾸기 때문에 반환하지 않고 그냥 써도 된다

-----------------------

    배열의 생성
    유사 배열 객체

-----------------------

    모듈
        (함수를 파일로 분리해서 참조해서 가져다 쓰는 것)
        한가지 기능 이상을 하고 있는 코드 집단
        * 모듈에서 가장 중요한 것은 "재사용성"이 있다  -->  가독성도 좋고 유지보수 때도 좋다

        파일 단위로 기능을 분리하여 다른 파일에서 함수나 객체 등을 참조하는 것 (참조 = 가지고 오는 것)
        ex) react, vue, next, svelt, qiwck, astro, remix 같은 현재 유행하고 있는
                프론트엔드 프레임워크(도구) 가 존재할 수 있는 가장 근본적인 이유
                ("모듈" 이라는 것이 없었다면 이 친구들은 가능하지 않았다)

    모듈 문법 :
    module.exports = { }  -->  객체코드블럭(중괄호) 안에 함수명 작성
    const name = require("./~~")  -->  파일명 작성 (" " 사용해서 문자열로 작성해야 됨)
    const newFunc = name.함수명  -->  변수에 파일 담아줬던 것에 .(닷) + 함수명 작성  -->  이러면 변수에 모듈화했던 "함수(기능 묶음)" 가 담긴다

    ==>  이런 식으로 함수를 "module.exports" 로 저장해두고, "require" 로 불러와서 사용할 수 있다

-----------------------

    for  ==>  (forEach,  for in,  for of)

    forEach : 모든 요소를 순회해서 반복  -->  "요소(el)" 뿐만 아니라 "인덱스" 와 "원본배열" 도 순회해서 가져올 수 있다
    for in : "객체의 키값" 을 반복문을 통해 사용  -->  객체 접근법을 사용하면 value 값도 가져올 수 있다 (닷 접근법 or 대괄호 접근법)
    for of : 이터러블한 객체에서 요소의 값만을 가져올 수 있음, index 없음  -->  대신 가독성이 좋다 (인덱스 필요 없을 때는 for of 사용)

    for문은 반복문
        ==> "순회" 해야 한다면 일반 for문은 가독성이 좋지 않다
        - 순회하지 않고, 반복에 대한 조건을 내가 마음대로 변경할 수 있다
        - 배열과 같이 이터러블한 객체가 아니더라도 사용이 가능하다  (이터러블 : 순회 가능하다)

    for(초기식, 조건식, 증감식) {
        ... 순회한다면 위 모든 조건이 필요 없다 :)
        if() return;  -->  다음 반복문을 실행하지 않고 종료
        if() continue;  -->  현재 반복문은 실행하지 않고, 다음 반복문으로 넘어갑니다 (continue 만나면 건너뜀, 처음으로 되돌아감)
    }

    forEach  -->  (요소, 인덱스, 원본배열)
        - index가 있기 때문에 순서를 보장한다
        - 모든 요소를 순차적으로 순회하는 반복문
        ==> 모든 요소를 순회해서 반복해야하는데, "인덱스"가 필요하다 -> forEach문

        arr.forEach((el, index, origin) => {  //-> map과 똑같아 보이지만, forEach은 새로운 배열을 반환하는 것이 아닌, 반복만 한다 (return하면 반복 종료)
            ... code
        })

-----------------------

    for in
        - 객체의 키값을 반복문을 통해 사용가능 (객체는 순서가 보장되어있지 않다)
        - 단점은 순서가 보장되지 않습니다 (애초에 index라고 하는 값이 없기 때문)

        ex) const junseok = {name: "김준석", age: 20}
        for(let k in : junseok) {   //-->  junseok 에 있는 "키"들이 "k" 에 담겨진다
            console.log(k)  //  name  age  (키가 나온다)
            console.log(junseok[k])  //  김준석  20  ("키에 대한 값"이 나온다)  -->  value 가져오려면 대괄호 접근법, 닷 접근법 아무거나 쓰면 된다
        }

-----------------------

    for of
        - 가독성이 굉장히 좋다
        - 모든 요소를 순회, 이터러블한 "객체" 에서 밖에 쓰지 못함
        - 요소의 "값" 만을 가지고 올 수 있음 (인덱스를 가지고 올 수 없음)  ==>  인덱스가 필요할 때 forEach  /  필요하지 않을 때 for of 사용하면 된다
        ==> 모든 요소를 순회해서 반복해야하는데, "값" 만 필요하다 -> for of문

        ex) const arr = [1, 2, 3, 4, 5]
        for(let el of arr) {
            console.log(el) // 1, 2, 3, 4, 5
        }

        // 여기서 let k 나 let el 을 여러분이 선언해준 것이기에, 이름은 맘대로 해줘도 된다

        // 순서가 보장되지 않는다고 하는 것은, 이 로직을 사용하고 나서, 이 로직이 끝날 때가지 기다리지 않는다는 의미이다

---------------------------------------------------------------------------------------

다음주 수업
    빌트인 객체 , 구조분해할당, set, map

    위에 다 종료되면
        dom-api (html에 자바스크립트를 가져다 쓰는 것)

---------------------------------------------------------------------------------------