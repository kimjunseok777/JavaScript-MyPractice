


/*
논리연산자 : 참이냐 거짓이냐를 따지는 연산자 (boolean 형)
    true / false
    ex)
    let a = 5;
    let b = 3;
    let c = 5;
    console.log(a > b) // true (초과일 때)
    console.log(a >= c) // true (이상일 때) : a 가 c 보다 크거나 같은지를 판단한다 (이상인지 판단한다)

    참, 거짓을 판단할 수 있는 연산이 조건에 들어왔을 때 -> 이것을 "논리연산자" 라고 한다 (boolean 형이다)
    true / false 를 출력
    대부분 "비교연산자" 와 같이 쓰임

비교연산자 :
    > , < , >= , <= , == , === , != , !==

    ==  동등비교 : "값" 만 비교한다  -->  "느슨한 비교"
    ===  일치비교 : "값" 과 "데이터 유형" 모두 비교한다  -->  "확실한 비교"
    !=  부등비교 : "값" 만 비교한다
    !==  불일치비교 : "값" 과 "데이터 유형" 모두 비교한다

        --> "동등비교" 보다 "일치비교" 가 더 많이 쓰인다  "==="  ( == 는 많이 안쓰임 )
        --> "부등비교" 보다 "불일치비교" 가 더 많이 쓰인다  "!=="  ( != 는 많이 안쓰임 )

        ex)
            a = 3;  (숫자)
            b = "3";  (문자열인 숫자)
            a == b ( true )  --> "값" 만 보기 때문에 true 가 나옴  //  true
            a === b ( false )  -->  "값" 과 "데이터유형" 모두 보기 때문에 false 가 나옴  //  false

-----------------------------------------------------------------------------------------------

    !=  부등비교 : "값만"  -->  "값" 이 안같아?  -->  값이 같지 않으면 true 인 것이다
    !==  불일치비교 : "값과 데이터 유형"  -->  "값" 과 "데이터 유형" 이 안같아?  -->  값이 같지 않으면 true 인 것이다
        ex)
            a = 3;
            b = "3";
            a != b (false)  -->   '값이 같지 않아?', '값이 안같아?' -> '아니오' 같아  -> 같지 않아야 true 같아야 false
                                                -> 여기서 '응' 같지 않아라는 답이 나오면 true 이다
                                            a랑 b는 값이 같지 않아? -> 아니(false), 값이 같아
                                            --> "부등비교" 는 값이 다르면 true  /  값이 같으면 false
                                            -->  데이터 유형은 비교하지 않기 때문에 값이 같은 결과로 나와서 false 가 나오는 것이다

            a !== b (true)  -->  값도 같은지 물어보고, 타입도 같은지 물어봄 -> 둘중에 하나라도 같으면 true 가 나와야함
                                                -> 왜냐면 '응 달라' 라는 말이 나오기 때문
                                            a랑 b는 값 혹인 데이터 유형이 같지 않아?, 값이 안같아?
                                            -> a,b 는 값은 아니, 같아(false)
                                            -> a,b 는 데이터 타입은 같지 않아(true)
                                            ----> true (응, 같지 않아  -->  데이터유형이 다르기 때문에 같지 않아  -->  true)

                                            --> "불일치비교" 는 둘중에 하나라도 다르면 true  /  값과 데이터유형 모두 같으면 false

                                            ( 다르다가 true, 같다가 false 이다 )

                                            ==> 즉, 부등비교와 불일치비교는 값이나 데이터가 틀린지를 확인하는 것이다
*/

let a = 5;
a = a + 1;
console.log(a) // 6
console.log(++a) // 7
console.log(a++) // 7  ++가 뒤어오면 마지막에 더하는 것 (출력을 하고 나서 마지막으로 더하는 것)
console.log(a) // 8  -->  이렇게 다음 줄에 오는 코드는 a++ 인 후위연산자가 계산되고 a가 찍히는 것이다

5 == 5; // true
5 == "5"; // true
5 == 8; // false
false == "0"; // true  --> 컴퓨터는 값을 0,1 로 구분한다 -> 그래서 false 는 계산이 더 빠른 '0' 으로 지정
false == "false"; // false  -->  "false" 는 값으로 구분되지 않는다 -> 문자 "false" 가 아닌 그냥 false 는 0인 값으로 구분

false == undefined // false  -->  false 인 이유는 false 는 명확히 값이 0 으로 존재한다
                                    //-->  그래서 false == "0" 이 true 가 나오는 것이다
                                    // -> 하지만 undefined 는 값이 없다, 값이 정의되어있지 않은 상태를 의미
                                    // ex ) let b; 같은 것을 값이 정의되어있지 않았기 때문에 undefined 라 한다

false == null // false  -->  null 은 값이 없다고 명시한 상태를 의미 / 반면 false 는 값이 0

undefined == null // true --> true인 이유는 둘 다 값이 없기 때문이다
                                // 이렇게 true 가 나올 수도 있으니, 부등비교 말고 불일치비교를 많이 사용하자

undefined === null // false

/*
    값은 둘다 비어있는데, 정의한 것, 정의하지 않은 것의 차이다 (null 은 값이 없다고 정의 내린 것이다)
*/

5 === 5; // true
5 === "5"; // false
5 == "5"; // true  -->  데이터 타입은 비교하지 않기 때문에 true 가 나온다

NaN === Nan // false  --> js에서 유일하게 자기 자신과 같지 않은 값 (안쓰인다고 보면 됨)

0 === -0 // true  -> 0은 양의 정수와 음의 정수에 포함되지 않기에 true 이다 (마이너스 붙인다고 달라지지 않는다)

5 != 8; // true  =  응, 값이 안같아
5 != 5; // false  =  아니, 값이 같아
5 != "5"; // false  =  아니, 값이 같아
5 !== 8; // true  =  응, 데이터유형은 같은데, 값이 안같아
5 !== 5; // false  =  아니, 데이터유형과 값 모두 같아
5 !== "5"; // true  =  응, 값은 같은데, 데이터유형이 안같아

//-----------------------------------------------------------------------------------------------

/*
    논리합 연산자 :  ||  -->  n개 중 하나라도 true 야?  -> 하나라도 트루가 있느냐 물어보는 것
    논리곱 연산자 :  &&  -->  n개 다 true 야?  ->  모든 조건을 만족하는지 물어보는 것 (모든 조건이 true 여야함)
                                     -->  논리곱 연산자는 true 면 다음 연산이나 결과로 넘어간다 (false 이면 넘어가지 않는다)
                                     -->  { a === "SIGN-IN" && <IsOpenModal/> }  -->  이런식으로 리액트에서 사용할 수 있다
    부정 연산자 :  !  -->  반대야?
    논리곱 연산자 ex :
        let a = 5;
        {a && 5 <IsModalOpen/>}  -->  a는 5와 값이 같기 때문에 오른쪽으로 계속 이어진다
        -->  모달창 컴포넌트가 화면에 랜더링 되는 것이다

    부정 연산자 ex)
        let b= true
        console.log( !b )  -->  false가 나온다  -->  true 에 !(부정연산) 을 붙여줘서 "반대" 가 되기 때문
*/

// 논리합 연산자 : 하나라도 true 인지 확인 (하나라도 true 이면 true 이다)
true || true  // true
true || false // true
false || true // true
false || false // false
false || false || true// true (논리합 연산자는 하나라도 true가 나오면 true 이다)

// 논리곱 연산자 : 하나라도 false 인지 확인 (하나라도 false 이면 false 이다)
true && true // true
true && false // false (논리곱 연산자는 하나라도 false가 나오면 false 이다)

let c = 5;
// 특정한 조건에만 실행하고 싶은 코드있을 때 사용 (true가 되기 위한 조건을 더 걸어주는 것이다)
// 많이 쓰이는 것이 &&(and : 둘다 true 야?) , ||(or : 둘중 하나라도 true야?)
if(c  > 1 && c > 4) {
    console.log(c) // 5 // true 로 실행 O  //--> false면 실행하지 않음
}
// c 가 1 과 4 이상이면 콘솔로그 실행
// 이런식으로 많이 쓰임

if(c  > 1 && c > 7) {
    console.log(c) // 실행하지 않음 // false 로 실행하지 않는다
}
// c 가 1 과 7 이상이면 콘솔로그 실행  -->  하지만 c 는 7 보다 작기 때문에 실행하지 않는다 (콘솔이 찍히지 않는다)

//-----------------------------------------------------------------------------------------------

/*
    삼항 연산자 : 항이 3개라는 이야기
        조건식 (true or false) ? true : false
            -> (여기서 조건식은 true , false 를 판단할 수 있는 식을 뜻한다)
            -> (조건식) ? (true) : (false) -> 이렇게 항이 총 3개이다
            -> false 부분에 또 다른 조건식을 써주면서 이어가면 항을 3개이상 만들어줄 수 있음 (하지만 가독성 안좋아짐)

    && 연산자 :
        조건식 && true
            -> 조건식이 맞으면 'true' 를 반환 / 거짓이면 '조건식' 을 반환

    ?? 연산자 :
*/

// 삼항 연산자 :
const d = 5;
const e = d > 4 ? "참" : "거짓";
// 삼항 연산자는 값에 분기(참과 거짓)가 생길 때 많이 쓰임  -->  참이면 왼쪽 , 거짓이면 오른쪽
// 삼항 연산자는 이어서 작성이 가능, 가독성이 좋지 않아서 항이 3~4항 정도로 항이 작을 때 많이 사용, 단순할 때 사용
console.log(e); // true --> 터미널에서 node 파일명 하면 "true" 가 나온다

// && 연산자 :
const f = d > 3 && "참"  // -> 조건이 트루이면 식과 끝까지 가는 것이고, 거짓이면 식을 본다
// d = 5 로 3보다 크기 때문에 "참" 이다 -> 만약 d 가 3보다 작으면 f = false 이다  -->  그럼 참이기에 f = "참"
// -> 조건이 true 이면 끝까지 가는 거고, true 가 아니면 여기서 false 로 멈추는 것이다
// && 연산자는 값이 존재할 때만 실행할 때 많이 쓰임
// 조건식에 변수의 값이 있을 때는 true, 없을 때는 false 가 나온다

let a1 = undefined
let b = a1 && "상품리스트"  // a1 이 true 일 때만 상품 리스트를 반환할 거라는 소리
// -> a1 이 undefined 이기 때문에 반환하지 않음, 하지만 a1 변수가 "상품리스트"로 채워지면 반환 함
// -> 값이 없기 때문에 false가 나와 상품리스트 x
// 여기서 a1 은 조건식이 아님 > 크거나 작다 그런 말이 없기 때문

// && 연산자 잘 모르겠다 --> 질문하기