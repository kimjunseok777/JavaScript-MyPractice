
백엔드와의데이터 통신
                  -----------
                  요청과 응답

클라이언트  --------------->  백엔드 서버  --------------->  처리(DB 와 통신하는 경우 많음, API)
                    http request
                    (header, body)
                    <---------------
                    http response
                    (header, body(data, status))

                    status 는 실패했을 때 상태
                    400 -> BAD REQUEST -> message, code
                    500 -> Network Error -> 백엔드 서버 오류

                    http response status code

------------------------------------------------------------------------------------------------

ajax
javascript의 비동기 통신, 서버 간의 데이터를 주고 받기 위해 만든 기능

axios  /  fetch
기존의 Web 에서는 비동기 요청을 위해 XML로 데이터 통신 (ajax)
그러나 XML의 데이터 형태는 개발자의 의도에 따라 데이터를 변형하기가 어려움
이를 보완하기 위하여 HTTP 요청에 최적화되어있고 편의성을 위한 추상화가 잘 되어있는
도구들이 생겨나기 시작했음

대표적으로 axios, fetch

fetch :
    ES6 부터 내장되어 안정성이 뛰어남
    promise 기반으로 생성되어 있어 간편하게 사용가능
    ex)
                ------ 백엔드 주소 "http://hunseok.com/sign-in
        fetch(url, {
            method: "POST",
            header: {
                "Accept" : "application/json",
                "Authorization" : "Bearer token"
            },
            body: JSON.stringfy({
                ...data
            })
            //--> "스트링 데이터" 만 주고 받을 수 있다, 그래서 stringfy 해준 것  -->  그래서 데이터 받을 때 json() 으로 json화 시켜줘야 사용할 수 있다
        }).then((res) => res.json()).then((res) => console.log(response))
                                    ------------- json 으로 변형

------------------------------------------------------------------------------------------------

OPEN API
api를 무료로 사용할 수 있도록 공개해둔 것


API
    두 소프트웨어가 서로 통신할 수 있도록하는 메커니즘(방법)

    ex)
        포켓몬 도감 api
        영화 개봉 api
        깃허브 api
        기상청에서 제공하는 주간 날씨 api
        유튜브 api

REST API
    데이터 (자원) 를 이름으로 구분하여 사용 목적에 맞게 API를 구분한 것
    => API 에 이름을 붙여준 것

    https://junseok.com/user
    => 사용자와 관련이 있다는 점은 알 수 있음 (마지막에 user 들어감)

    method :
        개발자들끼리의 약속, 목적에 맞게 URL을 구분
        보통은 백엔드 개발자가 임의적으로 설정, 프론트엔드 개발자는 백엔드가
        정의한 메소드에 맞게 데이터를 전송

        get
        --> 얻다, 가져오다 (조회한다) --> 유저의 프로필 조회
        --> request body에 data를 전송하지 못한다, 오로지 주소로만 통신

        post
        --> 물품을 보내는 것(택배), 생성에 많이 쓰임
        --> request body 에 data를 전송할 수 있다, 주소로도 보낼 수 있음 (만능)

        put
        --> 놓다, 모든 데이터를 대체하는 것 (수정)

        patch
        --> 작은 조각, 일부 데이터를 수정하는 것 (닉네임만 바꾸는 것, 프로필만 바꾸는 것) (수정)

        delete
        --> 삭제

        단점 : 데이터를 주고 받는 것에 있어서 하나의 URL과 method라고 한다면 동일한 데이터를
        주고 받야한다. 따라서 데이터 내용이 조금만 달라도 다른 URL을 생성해야 REST FULL하게 된다.
        --> json으로 데이터를 구분할 수 있는 : graphQL 을 사용하게 된 계기

------------------------------------------------------------------------------------------------

자바스크립트 실행 컨텍스트
    : 자바스크립트가 브라우저에서 실행되는 환경

    1. Global Execution Context (전역 실행 컨텍스트)
            처음으로 자바스크립트가 실행되면 생성되는 컨텍스트
            전역으로 생성되는 객체나 값을 관리

    2. Function Execution Context (함수 실행 컨텍스트)
            각 함수가 실행될 때 마다 생성되는 컨텍스트

    3. 그 외

-------------------------------------------------------------------

    1. 평가
            실행 컨텍스트가 생성된 후 변수나 함수 선언문들을 파악하여 현재 스코프에서 사용이 가능한
            식별자 등을 컨텐스트에 등록
            
            '호이스팅' 이라는 말은 원래 자바스크립트 공식 언어가 아니다. 다만 평가 과정에서
            변수들이 먼저 등록되는 현상에 의하여 할당 전에 값이 인식되는 것을 개발자들 사이에서
            '호이스팅' 이라고 불렀을 뿐

    2. 실행
            선언문을 제외한 호출, 실행 과정에서 소스코드에 필요한 정보를 컨텍스트에서 부터 찾고
            변수의 값이 변경되면 변수의 값을 초기화하여 재할당하는 것

-------------------------------------------------------------------

    실행컨텍스트 내부

            LexicalEnvironment (렉시컬 환경)
                -> 스코프를 관리, 이 컨텍스트에서 사용할 수 있는 값들이 저장되는 공간 (변수가 저장되는 공간)

                Environment Record
                    declarative Environment Record (let, const 가 저장됨)
                    Object Environment Record (그외, var)

                OuterLexicalEnvironmentReference
                    스코프체인의 역할을 맡고 있다

-------------------------------------------------------------------
            
            전역 객체
                    빌트인객체 : ESMAScript에 의하여 정의된 내장 객체

-------------------------------------------------------------------

    클로저
            " 기억하고 있다 "
            클로저는 자바스크립트 뿐만이 아니라 함수를 일급객체 (실행, 컴파일)
            모든 언어에서 사용되는 특성

            *** "클로저는 메모리에서 해체되었더라도 자신이 생성되었을 때의 환경을 기억하고 사용하는 함수" ***
            ex)
                function addNum(num) {
                    const toAdd = num;

                    return function (number) {
                        return toAdd + number
                    }
                }

                const add5 = addNum(5)  //  function
                add5(3)  //  8  -->  처음에 만들었던 환경을 기억하고 있다

-------------------------------------------------------------------

            클로저 사용하는 이유
                1. 상태은닉
                        처음에 만들어졌던 환경 이외는 다른 함수는 상태 값을 알 필요가 없다


                2. 상태공유
                        하나의 함수에서 값이 변경이 되면 그 값을 기억하고 있다가 사용할 수 있는 것
                        ex)
                            function makeStudent(teacher) {
                                return function(name) {
                                    return {
                                        name : name;
                                        getTeacher() {
                                            return teacher
                                        }
                                        setTeacher(name) {
                                            teacher = name
                                        }
                                    }
                                }
                            }

                            const 철수 = makeStudent("성용") ("철수)
                            철수.getTeacher()  //  성용
                            철수.setTeacher("용성")
                            철수.getTeacher()  //  용성
                            

                3. 상태기억

------------------------------------------------------------------------------------------------

자바스크립트 추가적으로 공부하면 좋은 것

+  this 바인딩 , 프로토타입 , 클래스

------------------------------------------------------------------------------------------------

React

1. 어느 정도에 대한 예습 (유튜브 검색 추천)
2. 어렵습니다. 평소보다는 복습이나 예습에 신경을 많이 써야한다.

------------------------------------------------------------------------------------------------